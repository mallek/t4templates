<#+
// <copyright file="LinqToSqlDataContextTemplate.tt" company="T4 Toolbox Team">
//  Copyright © T4 Toolbox Team. All Rights Reserved.
// </copyright>

/// <summary>
/// Generates the generated Data Context subclass based on the LINQ to SQL DBML
/// </summary>
/// <remarks>
/// <para>
/// While MSLinqToSQLGenerator produces DataContext code that always uses an empty,
/// explicitly created AttributeMappingSource in constructors that don’t receive
/// mappingSource as a parameter, this generator simply calls the matching base
/// constructor.
/// </para>
/// <para>
/// While MSLinqToSQLGenerator uses fully-qualified, global:: type names, this template
/// produces code with “using” directives and abbreviated names.
/// </para>
/// </remarks>
public class LinqToSqlDataContextTemplate: Template
{
    /// <summary>
    /// Deserialized LINQ to SQL model (.dbml) for which entity objects will be generated
    /// </summary>
    /// <remarks>
    /// This property is automatically assigned by <see cref="LinqToSqlGenerator"/>. You
    /// must assign this property manually if you are using this template separately.
    /// </remarks>
    public Database Database { get; set; }

    /// <summary>
    /// Generates a strongly-typed LINQ to SQL Data Context subclass
    /// </summary>
    protected override void RenderCore()
    {
#>
// <autogenerated>
//   This file was generated by T4 code generator <#= System.IO.Path.GetFileName(TransformationContext.Host.TemplateFile) #>.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

namespace <#= this.Database.ContextNamespace #>
{
    using System.Data;
    using System.Data.Linq;
    using System.Data.Linq.Mapping;
<#+
        this.PushIndent("    ");
        this.RenderUsingDirectives();
        this.WriteLine(string.Empty);
        this.RenderDatabaseAttribute();
        this.PopIndent();
#>
    <#= AccessModifier(this.Database) #> <#= InheritanceModifier(this.Database) #>partial class <#= this.Database.Class #> : <#= this.GetBaseClass() #>
    {
        #region Constructors
<#+
        this.PushIndent("        ");
        this.RenderDefaultConstructor();
        this.PopIndent();
#>

        public <#= this.Database.Class #>(string connection)
            : base(connection)
        {
            this.OnCreated();
        }

        public <#= this.Database.Class #>(IDbConnection connection)
            : base(connection)
        {
            this.OnCreated();
        }

        public <#= this.Database.Class #>(string connection, MappingSource mappingSource)
            : base(connection, mappingSource)
        {
            this.OnCreated();
        }

        public <#= this.Database.Class #>(IDbConnection connection, MappingSource mappingSource)
            : base(connection, mappingSource)
        {
            this.OnCreated();
        }

        #endregion

        #region Table properties
<#+
        this.PushIndent("        ");
        Array.ForEach(this.Database.Table, this.RenderProperty);
        this.PopIndent();
#>

        #endregion

        #region Extensibility Methods

        partial void OnCreated();
<#+
        this.PushIndent("        ");
        Array.ForEach(this.Database.Table, this.RenderExtensibilityMethods);
        this.PopIndent();
#>

        #endregion
    }
}
<#+
    }

    /// <summary>
    /// Verifies code generation parameters
    /// </summary>
    protected override void Validate()
    {
        if (this.Database == null)
        {
            throw new TransformationException("Database property must be assigned");
        }

        Validate(this.Database);
    }

    /// <summary>
    /// Verifies properties the specified <paramref name="connection"/> used for code generation
    /// </summary>
    private static void Validate(Connection connection)
    {
        if (connection.Mode == ConnectionMode.ConnectionString)
        {
            if (string.IsNullOrEmpty(connection.ConnectionString))
            {
                throw new TransformationException("ConnectionString property of the Connection object is not specified");
            }
        }
        else
        {
            if (string.IsNullOrEmpty(connection.SettingsPropertyName))
            {
                throw new TransformationException("SettingsPropertyName property of the Connection object is not specified");
            }

            if (connection.Mode == ConnectionMode.AppSettings)
            {
                if (string.IsNullOrEmpty(connection.SettingsObjectName))
                {
                    throw new TransformationException("SettingsObjectName property of the Connection object is not specified");
                }
            }
        }
    }

    /// <summary>
    /// Verifies properties the specified <paramref name="database"/> used for code generation
    /// </summary>
    private static void Validate(Database database)
    {
        if (string.IsNullOrEmpty(database.Class))
        {
            throw new TransformationException("DataContext Name is not specified in the .dbml");
        }

        if (database.Connection != null)
        {
            Validate(database.Connection);
        }

        if (string.IsNullOrEmpty(database.ContextNamespace))
        {
            throw new TransformationException("ContextNamespace property of the Database object must be assigned");
        }

        // If there are no tables defined in the model, initialize the array to avoid checking it for null every time
        database.Table = database.Table ?? new Table[0];
        Array.ForEach(database.Table, Validate);
    }

    /// <summary>
    /// Verifies properties the specified <paramref name="table"/> used for code generation
    /// </summary>
    private static void Validate(Table table)
    {
        if (string.IsNullOrEmpty(table.Member))
        {
            throw new TransformationException("Member property of a Table object is not specified in the model");
        }

        if (table.Type == null)
        {
            throw new TransformationException("Type property of a Table object is not specified in the model");
        }

        if (string.IsNullOrEmpty(table.Type.Name))
        {
            throw new TransformationException("Name property of a Type object is not specified in the model");
        }
    }

    /// <summary>
    /// Returns access modifier (public, internal) for the specified <paramref name="database"/>
    /// </summary>
    private static string AccessModifier(Database database)
    {
        return database.AccessModifier.ToString().ToLower();
    }

    private string GetBaseClass()
    {
        if (string.IsNullOrEmpty(this.Database.BaseType))
        {
            return "DataContext";
        }

        return this.Database.BaseType;
    }

    /// <summary>
    /// Returns inheritance modifier (sealed, abstract or none) for the specified <paramref name="database"/>
    /// </summary>
    private static string InheritanceModifier(Database database)
    {
        if (database.ModifierSpecified)
        {
            return database.Modifier.ToString().ToLower() + " ";
        }

        return string.Empty;
    }

    /// <summary>
    /// Renders [Database(...)] attribute if mapping is specified in the model
    /// </summary>
    private void RenderDatabaseAttribute()
    {
        if (!string.IsNullOrEmpty(this.Database.Name))
        {
#>
[Database(Name = "<#= this.Database.Name #>")]
<#+
        }
    }

    /// <summary>
    /// Renders default constructor for the DataContext class if the database connection
    /// information is specified in the model
    /// </summary>
    private void RenderDefaultConstructor()
    {
        if (this.Database.Connection != null)
        {
            Connection connection = this.Database.Connection;
#>

public <#= this.Database.Class #>()
<#+
            switch (connection.Mode)
            {
                case ConnectionMode.ConnectionString:
#>
    : base("<#= connection.ConnectionString #>")
<#+
                    break;
                case ConnectionMode.WebSettings:
#>
    : base(ConfigurationManager.ConnectionStrings["<#= connection.SettingsPropertyName #>"].ConnectionString)
<#+
                    break;
                case ConnectionMode.AppSettings:
#>
    : base(<#= connection.SettingsObjectName #>.Default.<#= connection.SettingsPropertyName #>)
<#+
                    break;
                default: throw new TransformationException("Unexpected Connection.Mode");
            }
#>
{
    this.OnCreated();
}
<#+
        }
    }

    /// <summary>
    /// Renders partial extensibility methods for the specified <paramref name="Table"/>
    /// </summary>
    private void RenderExtensibilityMethods(Table table)
    {
#>

partial void Insert<#= table.Type.Name #>(<#= table.Type.Name #> instance);

partial void Update<#= table.Type.Name #>(<#= table.Type.Name #> instance);

partial void Delete<#= table.Type.Name #>(<#= table.Type.Name #> instance);
<#+
    }

    /// <summary>
    /// Renders property for the specified <paramref name="table"/>
    /// </summary>
    private void RenderProperty(Table table)
    {
#>

public Table<<#= table.Type.Name #>> <#= table.Member #>
{
    get { return this.GetTable<<#= table.Type.Name #>>(); }
}
<#+
    }

    /// <summary>
    /// Renders conditional using directives
    /// </summary>
    private void RenderUsingDirectives()
    {
        if (this.Database.Connection != null && this.Database.Connection.Mode == ConnectionMode.WebSettings)
        {
            this.WriteLine("using System.Configuration;");

            VSLangProj.VSProject project = (VSLangProj.VSProject)TransformationContext.Project.Object;
            project.References.Add("System.Configuration");
        }
    }
}
#>