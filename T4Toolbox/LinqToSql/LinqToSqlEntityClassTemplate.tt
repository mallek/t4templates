<#+
// <copyright file="LinqToSqlEntityClassTemplate.tt" company="T4 Toolbox Team">
//  Copyright © T4 Toolbox Team. All Rights Reserved.
// </copyright>

/// <summary>
/// Generates the generated Entity class based on the LINQ to SQL DBML
/// </summary>
/// <remarks>
/// There are several important differences in code produced by this template compared
/// to the standard MSLinqToSQLGenerator.
/// <para>
/// While MSLinqToSQLGenerator uses fully-qualified, global:: type names, this template
/// produces code with “using” directives and abbreviated names. This is done to make
/// the generated code easier to read.
/// </para>
/// <para>
/// While MSLinqToSQLGenerator generates field names as property name with an
/// underscore prefix, this method simply converts the property name to camelCase.
/// This is done for consistency with the StyleCop rule SA1306: Variable names
/// must start with a lower-case letter.
/// </para>
/// <para>
/// While MSLinqToSQLGenerator assumes that unknown data types are reference types
/// this method assumes that unknown types are value types. Assuming that users
/// will mostly use built-in types or known CLR types in the model, the most
/// frequently used custom types will be enumerations. Treating unknown types as
/// value types allows us to generate nullable enum types when model defines a
/// nullable property.
/// </para>
/// <para>
/// While MSLinqToSQLGenerator always emits [InheritanceMapping] attributes with
/// inheritance code values enclosed in double quotation marks, making them strings,
/// this generator emits them verbatim, preserving the original data type. This
/// allows using enum values as inheritance code directly, without the need to
/// convert. User can still use string values by enclosing them in double quotation
/// marks in the model/designer.
/// </para>
/// <para>
/// While MSLinqToSQLGenerator produces Entity code that fires PropertyChanging
/// event with empty property name, this template produces code fires PropertyChanging
/// events with actual property names
/// </para>
/// </remarks>
public class LinqToSqlEntityClassTemplate: Template
{
    /// <summary>
    /// Contains <see cref="Association"/> objects extracted from the the current
    /// <see cref="Type"/> for quick access.
    /// </summary>
    private System.Collections.Generic.List<Association> associations;

    /// <summary>
    /// Contains <see cref="Column"/> object extracted from the the current <see cref="Type"/>
    /// for quick access.
    /// </summary>
    private System.Collections.Generic.List<Column> columns;

    /// <summary>
    /// Stores serialization order number of the last generated column or association property.
    /// </summary>
    private int dataMemberOrder;

    /// <summary>
    /// Indicates whether current <see cref="Table"/> has a <see cref="Column"/> object
    /// with <see cref="Column.IsForeignKey"/> property set to <c>true</c>.
    /// </summary>
    private bool tableHasPrimaryKey;

    /// <summary>
    /// Indicates whether current <see cref="Type"/> has an <see cref="Association"/> object
    /// that needs to be serialized and requires supporting code.
    /// </summary>
    private bool typeHasSerializableAssociation;

    /// <summary>
    /// Gets or sets a <see cref="Type"/> object that encapsulates definition of
    /// the base type of the Data Class.
    /// </summary>
    /// <remarks>
    /// This property must be specified for a derived data class.
    /// </remarks>
    public Type BaseType { get; set; }

    /// <summary>
    /// Gets or sets LINQ to SQL database model
    /// </summary>
    public Database Database { get; set; }

    /// <summary>
    /// Gets or sets a <see cref="Table"/> object that encapsulates a database table
    /// to which a LINQ to SQL Data Class is mapped.
    /// </summary>
    public Table Table { get; set; }

    /// <summary>
    /// Gets or sets <see cref="Type"/> object that encapsulates Data Class defined
    /// in the LINQ to SQL model.
    /// </summary>
    public Type Type { get; set; }

    /// <summary>
    /// Generates a partial entity class for the specified <see cref="Type"/>
    /// </summary>
    protected override void RenderCore()
    {
        this.dataMemberOrder = 0;
        this.ParseTypeDefinition();
#>
// <autogenerated>
//   This file was generated by T4 code generator <#= System.IO.Path.GetFileName(TransformationContext.Host.TemplateFile) #>.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

namespace <#= this.Database.EntityNamespace #>
{
    using System;
    using System.ComponentModel;
    using System.Data.Linq;
    using System.Data.Linq.Mapping;
<#+
        this.PushIndent("    ");
        this.RenderUsingDirectives();
        this.WriteLine(string.Empty);
        this.RenderDataContractAttribute();
        this.RenderTableAttribute();
        this.RenderInheritanceMappingAttributes(this.Type);
        this.PopIndent();
#>
    <#= AccessModifier(this.Type) #> <#= InheritanceModifier(this.Type) #>partial class <#= this.Type.Name #><#= this.GetClassBase() #>
    {
<#+
        this.PushIndent("        ");
        this.columns.ForEach(this.RenderField);
        this.associations.ForEach(this.RenderField);
        this.RenderSerializationField();
        this.RenderConstructor();
        this.RenderPropertyChangeEvents();
        this.columns.ForEach(this.RenderProperty);
        this.associations.ForEach(this.RenderProperty);
        this.RenderPropertyChangeMethods();
        this.associations.ForEach(this.RenderEntitySetActionMethods);
        this.RenderExtensibilityMethods();
        this.RenderSerializationMethods();
        this.PopIndent();
#>
    }
}
<#+
    }

    /// <summary>
    /// Validates code generation parameters
    /// </summary>
    protected override void Validate()
    {
        if (this.Database == null)
        {
            throw new TransformationException("Database property must be assigned");
        }

        if (string.IsNullOrEmpty(this.Database.EntityNamespace))
        {
            throw new TransformationException("EntityNamespace property of the Database object must be assigned");
        }

        if (this.Type == null)
        {
            throw new TransformationException("Type property must be assigned");
        }

        // Make sure Items array is not null so that we don't have to check every time
        if (this.Type.Items == null)
        {
            this.Type.Items = new object[0];
        }

        if (this.Table == null)
        {
            throw new TransformationException("Table property must be assigned");
        }
    }

    /// <summary>
    /// Returns access modifier (public, internal, etc.) of the specified <paramref name="association"/>.
    /// </summary>
    private static string AccessModifier(Association association)
    {
        return ToCSharp(association.AccessModifier);
    }

    /// <summary>
    /// Returns access modifier (public, internal, etc.) of the specified <paramref name="column"/>.
    /// </summary>
    private static string AccessModifier(Column column)
    {
        return ToCSharp(column.AccessModifier);
    }

    /// <summary>
    /// Returns access modifier (public, internal, etc.) of the specified <paramref name="type"/>.
    /// </summary>
    private static string AccessModifier(Type type)
    {
        return ToCSharp(type.AccessModifier);
    }

    /// <summary>
    /// Converts the specified member name to camelCase.
    /// </summary>
    private static string CamelCase(string name)
    {
        return Char.ToLower(name[0]) + name.Substring(1);
    }

    /// <summary>
    /// Converts built-in C# type name to a fully-qualified CLR type name
    /// </summary>
    private static string ClrTypeName(string typeName)
    {
        switch (string.Intern(typeName))
        {
            case "bool":     return "System.Boolean";
            case "byte":     return "System.Byte";
            case "sbyte":    return "System.SByte";
            case "char":     return "System.Char";
            case "decimal":  return "System.Decimal";
            case "double":   return "System.Double";
            case "float":    return "System.Single";
            case "int":      return "System.Int32";
            case "uint":     return "System.UInt32";
            case "long":     return "System.Int64";
            case "ulong":    return "System.UInt64";
            case "object":   return "System.Object";
            case "short":    return "System.Int16";
            case "ushort":   return "System.UInt16";
            case "string":   return "System.String";
            case "DateTime": return "System.DateTime";
            case "Binary":   return "System.Data.Linq.Binary";
            default:         return typeName;
        }
    }

    /// <summary>
    /// Converts a fully-qualified CLR type name to a built-in C# type name
    /// </summary>
    private static string CSharpTypeName(string typeName)
    {
        switch (string.Intern(typeName))
        {
            case "System.Boolean":          return "bool";
            case "System.Byte":             return "byte";
            case "System.SByte":            return "sbyte";
            case "System.Char":             return "char";
            case "System.Decimal":          return "decimal";
            case "System.Double":           return "double";
            case "System.Single":           return "float";
            case "System.Int32":            return "int";
            case "System.UInt32":           return "uint";
            case "System.Int64":            return "long";
            case "System.UInt64":           return "ulong";
            case "System.Object":           return "object";
            case "System.Int16":            return "short";
            case "System.UInt16":           return "ushort";
            case "System.String":           return "string";
            case "System.DateTime":         return "DateTime";
            case "System.Data.Linq.Binary": return "Binary";
            default:                        return typeName;
        }
    }

    /// <summary>
    ///    Returns field name for the specified <paramref name="association"/>
    /// </summary>
    private static string FieldName(Association association)
    {
        return CamelCase(association.Member);
    }

    /// <summary>
    ///    Returns field name for the specified <paramref name="column"/>
    /// </summary>
    private static string FieldName(Column column)
    {
        if (!string.IsNullOrEmpty(column.Member))
            return CamelCase(column.Member);
        else
            return CamelCase(column.Name);
    }

    /// <summary>
    /// Returns an Association object that represents a foreign key which contains
    /// the specified <paramref name="column"/> or null, if the column is not a part
    /// of any foreign key.
    /// </summary>
    private Association FindForeignKey(Column column)
    {
        foreach (Association association in this.associations)
        {
            if (association.IsForeignKey && !string.IsNullOrEmpty(association.ThisKey))
            {
                string[] columnNames = association.ThisKey.Split(new char[]{',', ' '});
                if (Array.IndexOf(columnNames, PropertyName(column)) >= 0)
                {
                    return association;
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Returns class-base specification of the entity class which may include base
    /// class and interfaces it implements.
    /// </summary>
    private string GetClassBase()
    {
        string classBase = string.Empty;

        if (this.BaseType != null)
        {
            classBase += this.BaseType.Name;
        }

        if (this.tableHasPrimaryKey)
        {
            if (classBase.Length > 0)
            {
                classBase += ", ";
            }

            classBase += "INotifyPropertyChanging, INotifyPropertyChanged";
        }

        if (classBase.Length > 0)
            return " : " + classBase;

        return string.Empty;
    }

    /// <summary>
    /// Returns names of columns in the specified association key.
    /// </summary>
    private static string[] GetColumnNamesFromKey(string key)
    {
        if (key == null)
            return new string[0];
        else
            return key.Split(new char[] { ',', ' ' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    /// <summary>
    /// Returns an array of <see cref="Column"/> object that represent the specified association key.
    /// </summary>
    private Column[] GetColumnsFromKey(string key)
    {
        string[] columnNames = GetColumnNamesFromKey(key);
        Column[] columns = new Column[columnNames.Length];
        for (var i = 0; i < columnNames.Length; i++)
        {
            columns[i] = this.columns.Find(column => PropertyName(column) == columnNames[i]);
            if (columns[i] == null)
            {
                throw new TransformationException(
                    string.Format("Association key is invalid. Field \"{0}\" doesn't exist", columnNames[i]));
            }
        }

        return columns;
    }

    /// <summary>
    /// Tries to find a <see cref="Type"/> with the specified <paramref name="typeName"/>
    /// in the inheritance hierarchy that starts with the specified <paramref name="baseType"/>.
    /// </summary>
    private static Type FindTypeByName(Type baseType, string typeName)
    {
        if (baseType.Name == typeName)
        {
            return baseType;
        }

        if (baseType.Type1 != null)
        {
            foreach (Type childType in baseType.Type1)
            {
                Type matchingType = FindTypeByName(childType, typeName);
                if (matchingType != null)
                {
                    return matchingType;
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Returns a type with the specified <paramref name="typeName"/> defined in the
    /// current <see cref="Database"/>.
    /// </summary>
    private Type GetTypeByName(string typeName)
    {
        foreach (Table table in this.Database.Table)
        {
            Type type = FindTypeByName(table.Type, typeName);
            if (type != null)
            {
                return type;
            }
        }

        throw new TransformationException(string.Format("Type {0} doesn't exist.", typeName));
    }

    /// <summary>
    /// Returns matching association from the target type of the specified <paramref name="association"/>
    /// </summary>
    private Association GetOtherAssociation(Association association)
    {
        Type otherType = this.GetTypeByName(association.Type);
        for (var i = 0; i < otherType.Items.Length; i++)
        {
            Association otherAssociation = otherType.Items[i] as Association;
            if (otherAssociation != null &&
                this.Type.Name == otherAssociation.Type &&
                association.OtherKey == otherAssociation.ThisKey)
            {
                return otherAssociation;
            }
        }

        throw new TransformationException(string.Format("Association with ThisKey ({0}) doesn't exist.", association.OtherKey));
    }

    /// <summary>
    /// Returns inheritance modifier (virtual, override, etc.) for the specified <paramref name="association"/>
    /// </summary>
    private static string InheritanceModifier(Association association)
    {
        return ToCSharp(association.Modifier, association.ModifierSpecified);
    }

    /// <summary>
    /// Returns inheritance modifier (virtual, override, etc.) for the specified <paramref name="column"/>
    /// </summary>
    private static string InheritanceModifier(Column column)
    {
        return ToCSharp(column.Modifier, column.ModifierSpecified);
    }

    /// <summary>
    /// Returns inheritance modifier (abstract, sealed, etc.) for the specified <paramref name="type"/>
    /// </summary>
    private static string InheritanceModifier(Type type)
    {
        if (type.ModifierSpecified)
        {
            return type.Modifier.ToString().ToLower() + " ";
        }

        // When "None" was selected in the designer
        return string.Empty;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="type"/> should be serialized.
    /// </summary>
    private bool IsDataContract(Type type)
    {
        return this.Database.Serialization == SerializationMode.Unidirectional &&
            type.AccessModifier == GeneratedTextTransformation.AccessModifier.Public;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="association"/> should be serialized.
    /// </summary>
    private bool IsDataMember(Association association)
    {
        return this.IsDataContract(this.Type) && association.IsForeignKey == false &&
            association.AccessModifier == GeneratedTextTransformation.AccessModifier.Public;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="column"/> should be serialized.
    /// </summary>
    private bool IsDataMember(Column column)
    {
        return this.IsDataContract(this.Type) &&
            column.AccessModifier == GeneratedTextTransformation.AccessModifier.Public;
    }

    /// <summary>
    /// Returns true if the specified <paramref name="association"/> has cardinality
    /// of one, such as if the association object represents a parent entity or a child
    /// entity in a one-to-one relationship.
    /// </summary>
    private static bool IsEntityRef(Association association)
    {
        return association.IsForeignKey || (association.CardinalitySpecified && association.Cardinality == Cardinality.One);
    }

    /// <summary>
    /// Extracts frequently used objects, such as <see cref="Column"/> and <see cref="Association"/>
    /// from the type definition for quick access.
    /// </summary>
    private void ParseTypeDefinition()
    {
        // Prepare all associations and columns for quick access
        this.associations = new System.Collections.Generic.List<Association>();
        this.columns = new System.Collections.Generic.List<Column>();
        for (int i = 0; i < this.Type.Items.Length; i++)
        {
            Column column = this.Type.Items[i] as Column;
            if (column != null)
            {
                this.columns.Add(column);
                continue;
            }

            Association association = this.Type.Items[i] as Association;
            if (association != null)
            {
                this.associations.Add(association);
                continue;
            }
        }

        // Determine if the type has a serializable association
        this.typeHasSerializableAssociation = this.associations.Exists(this.IsDataMember);

        // Determine if table has primary key
        this.tableHasPrimaryKey = false;
        for (int i = 0; i < this.Table.Type.Items.Length; i++)
        {
            Column column = this.Table.Type.Items[i] as Column;
            if (column != null && column.IsPrimaryKey)
            {
                this.tableHasPrimaryKey = true;
                break;
            }
        }
    }

    /// <summary>
    /// Converts the specified name to PascalCase.
    /// </summary>
    private static string PascalCase(string name)
    {
        return Char.ToUpper(name[0]) + name.Substring(1);
    }

    /// <summary>
    /// Returns property name for the specified <paramref name="association"/>
    /// </summary>
    private static string PropertyName(Association association)
    {
        return PascalCase(association.Member);
    }

    /// <summary>
    /// Returns property name for the specified <paramref name="column"/>
    /// </summary>
    private static string PropertyName(Column column)
    {
        if (!string.IsNullOrEmpty(column.Member))
            return PascalCase(column.Member);
        else
            return PascalCase(column.Name);
    }

    /// <summary>
    /// Renders [Association(...)] attribute for a property
    /// </summary>
    private void RenderAssociationAttribute(Association association)
    {
        System.Collections.Generic.List<string> parameters = new System.Collections.Generic.List<string>();

        if (!string.IsNullOrEmpty(association.Name))
        {
            parameters.Add(string.Format("Name = \"{0}\"", association.Name));
        }

        if (!string.IsNullOrEmpty(FieldName(association)))
        {
            parameters.Add(string.Format("Storage = \"{0}\"", FieldName(association)));
        }

        if (!string.IsNullOrEmpty(association.ThisKey))
        {
            parameters.Add(string.Format("ThisKey = \"{0}\"", association.ThisKey));
        }

        if (!string.IsNullOrEmpty(association.OtherKey))
        {
            parameters.Add(string.Format("OtherKey = \"{0}\"", association.OtherKey));
        }

        if (!association.IsForeignKey && association.CardinalitySpecified && association.Cardinality == Cardinality.One)
        {
            parameters.Add("IsUnique = true");
        }

        if (association.IsForeignKey || association.IsForeignKeySpecified)
        {
            parameters.Add(string.Format("IsForeignKey = {0}", association.IsForeignKey.ToString().ToLower()));
        }

        if (association.DeleteOnNull || association.DeleteOnNullSpecified)
        {
            parameters.Add(string.Format("DeleteOnNull = {0}", association.DeleteOnNull.ToString().ToLower()));
        }

        if (!string.IsNullOrEmpty(association.DeleteRule))
        {
            parameters.Add(string.Format("DeleteRule = \"{0}\"", association.DeleteRule));
        }

        this.WriteLine("[Association({0})]", string.Join(", ", parameters.ToArray()));
    }

    /// <summary>
    /// Renders [Column(...)] attribute for a property
    /// </summary>
    private void RenderColumnAttribute(Column column)
    {
        System.Collections.Generic.List<string> parameters = new System.Collections.Generic.List<string>();

        if (!string.IsNullOrEmpty(column.Name))
        {
            parameters.Add(string.Format("Name = \"{0}\"", column.Name));
        }

        if (!string.IsNullOrEmpty(FieldName(column)))
        {
            parameters.Add(string.Format("Storage = \"{0}\"", FieldName(column)));
        }

        if (column.CanBeNull || column.CanBeNullSpecified)
        {
            parameters.Add(string.Format("CanBeNull = {0}", column.CanBeNull.ToString().ToLower()));
        }

        if (!string.IsNullOrEmpty(column.DbType))
        {
            parameters.Add(string.Format("DbType = \"{0}\"", column.DbType));
        }

        if (!string.IsNullOrEmpty(column.Expression))
        {
            parameters.Add(string.Format("Expression = \"{0}\"", column.Expression));
        }

        if (column.IsDbGenerated || column.IsDbGeneratedSpecified)
        {
            parameters.Add(string.Format("IsDbGenerated = {0}", column.IsDbGenerated.ToString().ToLower()));
        }

        if (column.IsDiscriminator || column.IsDiscriminatorSpecified)
        {
            parameters.Add(string.Format("IsDiscriminator = {0}", column.IsDiscriminator.ToString().ToLower()));
        }

        if (column.IsPrimaryKey || column.IsPrimaryKeySpecified)
        {
            parameters.Add(string.Format("IsPrimaryKey = {0}", column.IsPrimaryKey.ToString().ToLower()));
        }

        if (column.IsVersion || column.IsVersionSpecified)
        {
            parameters.Add(string.Format("IsVersion = {0}", column.IsVersion.ToString().ToLower()));
        }

        if (column.UpdateCheck != default(UpdateCheck))
        {
            parameters.Add(string.Format("UpdateCheck = UpdateCheck.{0}", column.UpdateCheck));
        }

        this.WriteLine("[Column({0})]", string.Join(", ", parameters.ToArray()));
    }

    /// <summary>
    /// Renders constructor of the entity class
    /// </summary>
    private void RenderConstructor()
    {
#>

public <#= this.Type.Name #>()
{
<#+
        foreach (Association association in this.associations)
        {
            if (IsEntityRef(association))
            {
#>
    this.<#= FieldName(association) #> = default(EntityRef<<#= association.Type #>>);
<#+
            }
            else
            {
#>
    this.<#= FieldName(association) #> = new EntitySet<<#= association.Type #>>(this.Attach<#= PropertyName(association) #>, this.Detach<#= PropertyName(association) #>);
<#+
            }
        }

        if (this.tableHasPrimaryKey)
        {
#>
    this.OnCreated();
<#+
        }
#>
}
<#+
    }

    /// <summary>
    /// Renders [DataContract] attribute for the entity class if serialization
    /// option was specified for the Data Context in the LINQ to SQL model.
    /// </summary>
    private void RenderDataContractAttribute()
    {
        if (this.IsDataContract(this.Type))
        {
            this.WriteLine("[DataContract]");
        }
    }

    /// <summary>
    /// Renders [DataMember] attribute for the association property if serialization
    /// option was specified for the Data Context in the LINQ to SQL model.
    /// </summary>
    private void RenderDataMemberAttribute(Association association)
    {
        if (this.IsDataMember(association))
        {
            this.WriteLine("[DataMember(Order = {0}, EmitDefaultValue = false)]", ++this.dataMemberOrder);
        }
    }

    /// <summary>
    /// Renders [DataMember] attribute for the column property if serialization
    /// option was specified for the Data Context in the LINQ to SQL model.
    /// </summary>
    private void RenderDataMemberAttribute(Column column)
    {
        if (this.IsDataMember(column))
        {
            this.WriteLine("[DataMember(Order = {0})]", ++this.dataMemberOrder);
        }
    }

    /// <summary>
    /// Renders partial extensibility methods of the entity class
    /// </summary>
    private void RenderExtensibilityMethods()
    {
        // MSLinqToSqlGenerator doesn't generate extensibility methods without primary key
        if (this.tableHasPrimaryKey)
        {
#>

#region Extensibility methods

partial void OnCreated();

partial void OnLoaded();

partial void OnValidate(ChangeAction action);
<#+
            foreach (Column column in this.columns)
            {
#>

partial void On<#= PropertyName(column) #>Changing(<#= TypeName(column) #> value);

partial void On<#= PropertyName(column) #>Changed();
<#+
            }
#>

#endregion
<#+
        }
    }

    /// <summary>
    /// Renders field declaration for the specified <paramref name="association"/>
    /// </summary>
    private void RenderField(Association association)
    {
        if (IsEntityRef(association))
        {
#>
private EntityRef<<#= association.Type #>> <#= FieldName(association) #>;
<#+
        }
        else
        {
#>
private EntitySet<<#= association.Type #>> <#= FieldName(association) #>;
<#+
        }
    }

    /// <summary>
    /// Renders field declaration for the specified <paramref name="column"/>
    /// </summary>
    private void RenderField(Column column)
    {
#>
private <#= TypeName(column) #> <#= FieldName(column) #>;
<#+
    }

    /// <summary>
    /// Renders [InheritanceMapping] attribute for the specified <paramref name="type"/>
    /// and all of its child types defined in the LINQ to SQL model.
    /// </summary>
    private void RenderInheritanceMappingAttributes(Type type)
    {
        if (this.BaseType == null)
        {
            if (!string.IsNullOrEmpty(type.InheritanceCode))
            {
                this.Write("[InheritanceMapping(Code={0}, Type=typeof({1})", type.InheritanceCode, type.Name);
                if (type.IsInheritanceDefault)
                    this.Write(", IsDefault=true");
                this.WriteLine(")]");
            }

            if (type.Type1 != null)
            {
                Array.ForEach(type.Type1, this.RenderInheritanceMappingAttributes);
            }
        }
    }

    /// <summary>
    /// Renders property for a Many-To-One or a One-To-One association
    /// </summary>
    private void RenderEntityRefProperty(Association association)
    {
        Column[] thisColumns = this.GetColumnsFromKey(association.ThisKey);
        string[] otherColumnNames = GetColumnNamesFromKey(association.OtherKey);
        if (thisColumns.Length != otherColumnNames.Length)
        {
            throw new TransformationException(string.Format(
                "Invalid association. Number of columns in ThisKey ({0}) and OtherKey ({1}) doesn't match",
                association.ThisKey, association.OtherKey));
        }

        Association otherAssociation = this.GetOtherAssociation(association);
#>
<#= AccessModifier(association) #> <#= InheritanceModifier(association) #><#= association.Type #> <#= PropertyName(association) #>
{
    get
    {
        return this.<#= FieldName(association) #>.Entity;
    }

    set
    {
        <#= association.Type #> previousValue = this.<#= FieldName(association) #>.Entity;
        if (previousValue != value || !this.<#= FieldName(association) #>.HasLoadedOrAssignedValue)
        {
            this.SendPropertyChanging("<#= PropertyName(association) #>");
            if (previousValue != null)
            {
                this.<#= FieldName(association) #>.Entity = null;
<#+
            if (otherAssociation.CardinalitySpecified && otherAssociation.Cardinality == Cardinality.One)
            {
#>
                previousValue.<#= PropertyName(otherAssociation) #> = null;
<#+
            }
            else
            {
#>
                previousValue.<#= PropertyName(otherAssociation) #>.Remove(this);
<#+
            }
#>
            }
            this.<#= FieldName(association) #>.Entity = value;
            if (value != null)
            {
<#+
            if (otherAssociation.CardinalitySpecified && otherAssociation.Cardinality == Cardinality.One)
            {
#>
                value.<#= PropertyName(otherAssociation) #> = this;
<#+
            }
            else
            {
#>
                value.<#= PropertyName(otherAssociation) #>.Add(this);
<#+
            }
#>
<#+
            for (var i = 0; i < thisColumns.Length; i++)
            {
#>
                this.<#= FieldName(thisColumns[i]) #> = value.<#= PascalCase(otherColumnNames[i]) #>;
<#+
            }
#>
            }
            else
            {
<#+
            for (var i = 0; i < thisColumns.Length; i++)
            {
#>
                this.<#= FieldName(thisColumns[i]) #> = default(<#= TypeName(thisColumns[i]) #>);
<#+
            }
#>
            }
            this.SendPropertyChanged("<#= PropertyName(association) #>");
        }
    }
}
<#+
    }

    /// <summary>
    /// Renders Attach/Detach methods for a One-to-Many association
    /// </summary>
    private void RenderEntitySetActionMethods(Association association)
    {
        if (IsEntityRef(association))
        {
            return;
        }

        Association otherAssociation = this.GetOtherAssociation(association);
#>

private void Attach<#= PropertyName(association) #>(<#= association.Type #> entity)
{
    this.SendPropertyChanging("<#= PropertyName(association) #>");
    entity.<#= PropertyName(otherAssociation) #> = this;
}

private void Detach<#= PropertyName(association) #>(<#= association.Type #> entity)
{
    this.SendPropertyChanging("<#= PropertyName(association) #>");
    entity.<#= PropertyName(otherAssociation) #> = null;
}
<#+
    }

    /// <summary>
    /// Renders property for a One-To-Many association
    /// </summary>
    private void RenderEntitySetProperty(Association association)
    {
#>
<#= AccessModifier(association) #> <#= InheritanceModifier(association) #>EntitySet<<#= association.Type #>> <#= PropertyName(association) #>
{
    get 
    {
<#+
        if (this.IsDataMember(association))
        {
#>
        if (this.serializing && !this.<#= FieldName(association) #>.HasLoadedOrAssignedValues)
        {
            return null;
        }

<#+
        }
#>
        return this.<#= FieldName(association) #>; 
    }

    set 
    { 
        this.<#= FieldName(association) #>.Assign(value); 
    }
}
<#+
    }

    /// <summary>
    /// Renders property definition for the specified <paramref name="association"/>
    /// </summary>
    private void RenderProperty(Association association)
    {
        this.WriteLine(string.Empty);
        this.RenderDataMemberAttribute(association);  // [DataMember(...)]
        this.RenderAssociationAttribute(association); // [Association(...)]
        if (IsEntityRef(association))
        {
            this.RenderEntityRefProperty(association);
        }
        else
        {
            this.RenderEntitySetProperty(association);
        }
    }

    /// <summary>
    /// Renders property definition for the specified <paramref name="column"/>
    /// </summary>
    private void RenderProperty(Column column)
    {
        this.WriteLine(string.Empty);
        this.RenderDataMemberAttribute(column); // [DataMember(...)]
        this.RenderColumnAttribute(column);     // [Column(...)]
#>
<#= AccessModifier(column) #> <#= InheritanceModifier(column) #><#= TypeName(column) #> <#= PropertyName(column) #>
{
    get
    {
        return this.<#= FieldName(column) #>;
    }

<#+
        // Generate property change notification code if table has primary key
        if (this.tableHasPrimaryKey)
        {
#>
    set
    {
        if (this.<#= FieldName(column) #> != value)
        {
<#+
            Association foreignKey = this.FindForeignKey(column);
            if (foreignKey != null)
            {
#>
            if (this.<#= FieldName(foreignKey) #>.HasLoadedOrAssignedValue)
            {
                throw new ForeignKeyReferenceAlreadyHasValueException();
            }
<#+
            }
#>
            this.On<#= PropertyName(column) #>Changing(value);
            this.SendPropertyChanging("<#= PropertyName(column) #>");
            this.<#= FieldName(column) #> = value;
            this.SendPropertyChanged("<#= PropertyName(column) #>");
            this.On<#= PropertyName(column) #>Changed();
        }
    }
<#+
        }
        else
        {
#>
    set
    {
        this.<#= FieldName(column) #> = value;
    }
<#+
        }
#>
}
<#+
    }

    /// <summary>
    /// Renders PropertyChange events
    /// </summary>
    private void RenderPropertyChangeEvents()
    {
        if (this.tableHasPrimaryKey && this.BaseType == null)
        {
#>

public event PropertyChangingEventHandler PropertyChanging;

public event PropertyChangedEventHandler PropertyChanged;
<#+
        }
    }

    /// <summary>
    /// Renders PropertyChange methods
    /// </summary>
    private void RenderPropertyChangeMethods()
    {
        if (this.tableHasPrimaryKey && this.BaseType == null)
        {
#>

protected virtual void SendPropertyChanging(string propertyName)
{
    if (this.PropertyChanging != null)
    {
        this.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));
    }
}

protected virtual void SendPropertyChanged(string propertyName)
{
    if (this.PropertyChanged != null)
    {
        this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
    }
}
<#+
        }
    }

    /// <summary>
    /// Generates a boolean field used as a flag to control serialization of 
    /// </summary>
    private void RenderSerializationField()
    {
        if (this.typeHasSerializableAssociation)
        {
#>

private bool serializing;
<#+
        }
    }

    /// <summary>
    /// Generates methods that receive serialization notifications
    /// </summary>
    private void RenderSerializationMethods()
    {
        if (this.typeHasSerializableAssociation)
        {
#>

[OnSerializing]
[EditorBrowsableAttribute(EditorBrowsableState.Never)]
internal void OnSerializing(StreamingContext context)
{
	this.serializing = true;
}

[OnSerialized]
[EditorBrowsableAttribute(EditorBrowsableState.Never)]
internal void OnSerialized(StreamingContext context)
{
	this.serializing = false;
}
<#+
        }
    }

    /// <summary>
    /// Renders [Table] attribute for the data class if it is mapped to a table.
    /// </summary>
    private void RenderTableAttribute()
    {
        if (this.BaseType == null && !string.IsNullOrEmpty(this.Table.Name))
        {
            this.WriteLine("[Table(Name = \"{0}\")]", this.Table.Name);
        }
    }

    /// <summary>
    /// Renders conditional using directives
    /// </summary>
    private void RenderUsingDirectives()
    {
        if (this.IsDataContract(this.Type))
        {
            this.WriteLine("using System.Runtime.Serialization;");

            VSLangProj.VSProject project = (VSLangProj.VSProject)TransformationContext.Project.Object;
            project.References.Add("System.Runtime.Serialization");
        }
    }

    /// <summary>
    /// Converts the specified enum value to C# access modifier ("protected", "private", etc.)
    /// </summary>
    private static string ToCSharp(AccessModifier accessModifier)
    {
        if (accessModifier == GeneratedTextTransformation.AccessModifier.ProtectedInternal)
            return "protected internal";
        else
            return accessModifier.ToString().ToLower();
    }

    /// <summary>
    /// Converts the specified enum value to C# inheritance modifier ("new", "override", etc.)
    /// </summary>
    private static string ToCSharp(MemberModifier modifier, bool specified)
    {
        if (specified)
        {
            if (modifier == MemberModifier.NewVirtual)
                return "new virtual ";
            else
                return modifier.ToString().ToLower() + " ";
        }

        // When "None" was selected in the designer
        return string.Empty;
    }

    /// <summary>
    /// Returns type of the specified <paramref name="column"/>, converted to a built-in C# type if possible.
    /// </summary>
    private static string TypeName(Column column)
    {
        // Use built-in C# type, if possible
        string typeName = CSharpTypeName(column.Type);
        if (column.CanBeNull) // If column allows null values
        {
            // Determine if the type is a value or a reference
            string clrName = ClrTypeName(column.Type);
            System.Type type = System.Type.GetType(clrName);

            // If the type is defined outside of mscorlib assembly
            if (type == null)
            {
                // Try to find it in the other assemblies
                foreach (System.Reflection.Assembly assembly in System.AppDomain.CurrentDomain.GetAssemblies())
                {
                    type = assembly.GetType(clrName);
                    if (type != null)
                    {
                        break;
                    }
                }
            }

            // Unless we know with certainty that column type is a reference
            if (type == null || type.IsValueType)
            {
                // Assume it's a value type and use a nullable type
                typeName += "?";
            }
        }

        return typeName;
    }
}
#>
