<#+
// <copyright file="NetSqlAzManStoreClassTemplate.tt" company="T4 Toolbox Team">
// Copyright © T4 Toolbox Team. All Rights Reserved.
// </copyright>

public class NetSqlAzManStoreClassTemplate : Template
{
    private NetSqlAzMan.Interfaces.IAzManStore authorizationStore;
    private string className = "AuthorizationStore";
    private string @namespace = string.Empty;

    /// <summary>
    /// Gets or sets the authorization store for which the class needs to be generated.
    /// </summary>
	/// <remarks>
	/// This property is automatically assigned by <see cref="NetSqlAzManWrapperGenerator"/>. You
	/// must assign this property manually if you are using this template separately.
	/// </remarks>
    public NetSqlAzMan.Interfaces.IAzManStore AuthorizationStore
    {
        get { return this.authorizationStore; }
        set { this.authorizationStore = value; }
    }

	/// <summary>
	/// Gets or sets the name of the wrapper class that will be generated.
	/// </summary>
	/// <remarks>
	/// This property is automatically assigned by <see cref="AzManWrapperGenerator"/>. If
	/// you are using this template separately, this property is "AuthorizationStore" by
	/// default.
	/// </remarks>
	public string ClassName
	{
		get { return this.className; }
		set { this.className = value; }
	}

    /// <summary>
    /// Gets or sets the namespace name where the wrapper class will be generated.
    /// </summary>
	/// <remarks>
	/// This property is automatically assigned by <see cref="AzManWrapperGenerator"/>. You
	/// must assign this property manually if you are using this template separately.
	/// </remarks>
    public string Namespace
    {
        get { return this.@namespace; }
        set { this.@namespace = value; }
    }

	/// <summary>
	/// Generates actual code for the wrapper class.
	/// </summary>
    protected override void RenderCore()
	{
#>// <autogenerated>
//   This file was generated by T4 code generator <#= System.IO.Path.GetFileName(TransformationContext.Host.TemplateFile) #>. 
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>
using System;
using System.Data.SqlClient;
using System.Security;
using System.Security.Principal;
using System.Threading;
using NetSqlAzMan;
using NetSqlAzMan.Interfaces;

namespace <#= this.Namespace #>
{
	/// <summary>
	/// Performs application security authorization.
	/// </summary>
	/// <remarks>
	/// This class encapsulates .Net SQL AzMan API.
	/// </remarks>
	public class <#= this.ClassName #>
	{
		private readonly IAzManStorage azManStorage;
        private readonly string azManStoreName;

		/// <summary>
		/// Creates a new instance of <see cref="<#= this.ClassName #>"/> class.
		/// </summary>
        /// <param name="connectionString">The connection string to connect to storage database.</param>
        /// <param name="storageName">Name of the .Net AzMan Storage.</param>
        /// <param name="storeName">Name of the .Net AzMan Storage.</param>
		public <#= this.ClassName #>(string connectionString, string storageName, string storeName)
		{
			if (connectionString == null)
				throw new ArgumentNullException("connectionString");
			if (storageName == null)
				throw new ArgumentNullException("storageName");
			if (storeName == null)
				throw new ArgumentNullException("storeName");
				
			try
			{
                azManStorage = new SqlAzManStorage(connectionString);
                azManStoreName = storeName;
            }
            catch (SqlException e)
            {
				throw new SecurityException(string.Format("Unable to open authorization store"), e);
            }
		}
		
<#+
        foreach (NetSqlAzMan.Interfaces.IAzManApplication application in this.AuthorizationStore.Applications.Values)
	    {
			try
			{
			    string applicationEnumName = NetSqlAzManWrapperGenerator.GetApplicationEnumName(application.Name);
#>
        /// <summary>
        /// Verifies that current windows user can perform the specified <paramref name="operation"/>.
        /// </summary>
        /// <param name="operation"><see cref="<#= applicationEnumName #>"/> enumerated value</param>
        /// <exception cref="InvalidOperationException">
        /// When <see cref="Thread.CurrentPrincipal"/> is not a <see cref="WindowsPrincipal"/>. 
        /// Use <see cref="AppDomain.SetPrincipalPolicy"/> or assign <see cref="Thread.CurrentPrincipal"/>
        /// to correct this problem.
        /// </exception>
        /// <exception cref="SecurityException">
        /// When the the current windows identity is not authorized to perform the operation.
        /// </exception>
        /// <remarks>
        /// Use this method to ensure that current windows user is authorized to perform an
        /// application operation. Current user is determined using <see cref="Thread.CurrentPrincipal"/>.
        /// Use <see cref="CanPerform(<#= applicationEnumName #>)"/> when throwing an exception is 
        /// not desirable. 
        /// </remarks>
		public void Authorize(<#= applicationEnumName #> operation)
		{
			Authorize(GetCurrentWindowsIdentity(), operation);
		}

        /// <summary>
        /// Verifies that <see cref="WindowsIdentity"/> can perform the specified 
        /// <paramref name="operation"/>.
        /// </summary>
        /// <param name="identity"><see cref="WindowsIdentity"/> object</param>
        /// <param name="operation"><see cref="<#= applicationEnumName #>"/> enumerated value</param>
        /// <exception cref="ArgumentNullException">
        /// When <paramref name="identity"/> is null
        /// </exception>
        /// <exception cref="SecurityException">
        /// When the <paramref name="identity"/> is not authorized to perform the operation.
        /// </exception>
        /// <remarks>
        /// Use this method to ensure that a specific windows user is authorized to perform an
        /// application operation. Use <see cref="CanPerform(WindowsIdentity, <#= applicationEnumName #>)"/>
        /// when throwing an exception is not desirable. 
        /// </remarks>
		public void Authorize(WindowsIdentity identity, <#= applicationEnumName #> operation)
		{
			if (!CanPerform(identity, operation))
			{
				throw new SecurityException(
					string.Format("{0} is not authorized to perform {1}", identity.Name, operation));
			}
		}
		
        /// <summary>
        /// Determines if current windows user can perform the specified <paramref name="operation"/>.
        /// </summary>
        /// <param name="operation"><see cref="<#= applicationEnumName #>"/> enumerated value</param>
        /// <returns>
        /// True, when the current user is authorized to perform the specified 
        /// <paramref name="operation"/>. Otherwise returns false.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        /// When <see cref="Thread.CurrentPrincipal"/> is not a <see cref="WindowsPrincipal"/>. 
        /// Use <see cref="AppDomain.SetPrincipalPolicy"/> or assign <see cref="Thread.CurrentPrincipal"/>
        /// to correct this problem.
        /// </exception>
        /// <remarks>
        /// Use this method to determine if current windows user is authorized to perform
        /// an application operation without throwing an exception. Current user is determined using
        /// <see cref="Thread.CurrentPrincipal"/>. 
        /// </remarks>
        /// <seealso cref="Authorize(<#= applicationEnumName #>)"/>
		public bool CanPerform(<#= applicationEnumName #> operation)
		{
			return CanPerform(GetCurrentWindowsIdentity(), operation);
		}		

        /// <summary>
        /// Determines if <see cref="WindowsIdentity"/> can perform the specified 
        /// <paramref name="operation"/>.
        /// </summary>
        /// <param name="identity"><see cref="WindowsIdentity"/> object</param>
        /// <param name="operation"><see cref="<#= applicationEnumName #>"/> enumerated value</param>
        /// <returns>
        /// True, when the <paramref name="identity"/> is authorized to perform the specified 
        /// <paramref name="operation"/>. Otherwise returns false.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// When <paramref name="identity"/> is null
        /// </exception>
        /// <remarks>
        /// Use this method to determine a specific windows user is authorized to perform
        /// an application operation without throwing an exception. 
        /// </remarks>
        /// <seealso cref="Authorize(WindowsIdentity, <#= applicationEnumName #>)"/>
		public bool CanPerform(WindowsIdentity identity, <#= applicationEnumName #> operation)
		{
			if (identity == null)
				throw new ArgumentNullException("identity");
			return CanPerform(identity, @"<#= application.Name #>", operation.ToString());
		}
<#+
			}
			finally
			{
//				System.Runtime.InteropServices.Marshal.ReleaseComObject(application);
			}
		}
#>

		#region private
		
		private bool CanPerform(WindowsIdentity identity, string applicationName, string operation)
		{
			try
			{
				AuthorizationType authorization = azManStorage.CheckAccess(azManStoreName, applicationName, operation, identity, DateTime.Now, true);
				return authorization == AuthorizationType.Allow;
			}
			catch (SqlException e)
			{
				throw new SecurityException(string.Format("Unable to check operation '{0}'", operation), e);
			}
		}
		
		private static WindowsIdentity GetCurrentWindowsIdentity()
		{
			WindowsPrincipal currentPrincipal = Thread.CurrentPrincipal as WindowsPrincipal;
			if (currentPrincipal != null)
			{
				WindowsIdentity currentIdentity = currentPrincipal.Identity as WindowsIdentity;
				if (currentIdentity != null)
					return currentIdentity;
			}
				
			throw new InvalidOperationException(
				"Current thread principal must be a WindowsPrincipal. Call " +
				"AppDomain.SetPrincipalPolicy(PrincipalPolicy.WindowsPrincipal) or " +
				"assign Thread.CurrentPrincipal to correct this problem");
		}

		#endregion 
	}
}
<#+
	}

    /// <summary>
    /// Validates template parameters
    /// </summary>
    protected override void Validate()
    {
        if (this.AuthorizationStore == null)
        {
            throw new TransformationException("AuthorizationStore property must be assigned");
        }

		if (string.IsNullOrEmpty(this.ClassName))
		{
			throw new TransformationException("ClassName property must be assigned");
		}

        if (string.IsNullOrEmpty(this.Namespace))
        {
            throw new TransformationException("Namespace property must be assigned");
        }
    }
}
#>
